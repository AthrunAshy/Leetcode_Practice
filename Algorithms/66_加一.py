# 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

# 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

# 你可以假设除了整数 0 之外，这个整数不会以零开头。

 

# 示例 1：

# 输入：digits = [1,2,3]
# 输出：[1,2,4]
# 解释：输入数组表示数字 123。
# 示例 2：

# 输入：digits = [4,3,2,1]
# 输出：[4,3,2,2]
# 解释：输入数组表示数字 4321。
# 示例 3：

# 输入：digits = [0]
# 输出：[1]
 

# 提示：

# 1 <= digits.length <= 100
# 0 <= digits[i] <= 9


# Python 代码：

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        n = len(digits)
        # 逆序遍历，n-1 位到 0 位（因为-1位不包含在循环中），步长为 -1
        for i in range(n - 1, -1, -1):
            # 如果当前位不是 9，则加 1 并返回
            if digits[i] != 9:
                digits[i] += 1
                # 如果刚好是最后一位非9，则不会进入for循环，直接把digits返回
                # 如果不是最后一位非9，则把后面的元素都置为0，表示进一位
                for j in range(i + 1, n):
                    digits[j] = 0
                return digits

        # digits 中所有的元素均为 9，则需要新建一个数组，把 1 加在最前面，后面补 n 个 0
        return [1] + [0] * n
    
# 如果 digits 的末尾没有 999，例如 [1,2,3][1, 2, 3][1,2,3]，
# 那么我们直接将末尾的数加一，得到 [1,2,4][1, 2, 4][1,2,4] 并返回；

# 如果 digits 的末尾有若干个 999，例如 [1,2,3,9,9][1, 2, 3, 9, 9][1,2,3,9,9]，
# 那么我们只需要找出从末尾开始的第一个不为 999 的元素，将该元素加一，得到 [1,2,4,9,9][1, 2, 4, 9, 9][1,2,4,9,9]。
# 随后将末尾的 999 全部置零，得到 [1,2,4,0,0][1, 2, 4, 0, 0][1,2,4,0,0] 并返回。

# 如果 digits 的所有元素都是 999，例如 [9,9,9,9,9][9, 9, 9, 9, 9][9,9,9,9,9]，
# 那么我们需要构造一个长度比 digits 多 1 位的新数组，将首元素置为 1，其余元素置为 0 即可。